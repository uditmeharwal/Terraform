it is an orchestration tool . it is also called k8s
monolyth - it is the application in which all the application included in a single application , it is very hard to manage , it is a single repository 
micro services -it is the collection of different component of an application which are devided according to their work , and incase any service may not working so we can maanage this without stoping the app 
for managing docker relaeted service we use kubernetes 
In this we can handel many coontainers or we can say we are working on a cluster 
--------------------------------------------------------------------------
--Architecture of kubernetes--
scheduler - it manage all time related activites and manage all schedules 
api server -it help to  communicate with worker leve 
controller manager - it is the head manager and manage all the activities 
pods -pods is the place where containers are running 
etcd - it is the database of the kubernetes
kublet - low level manager , it work as worker node 
service proxy 
kubectl - help to control and instruct to hole cluster 
------------------------------------------------------------------------
--- kubernetes cluster types -----
-> kubeadm - we use two or more instance and attach them together and make a cluster , it is very expensive  
-> minikube (local system )
-> kind cluster -> kubernetes in docker 
-> EKS /AKS -> Elastic kubernetes service it is online cloud service 
--------------------------------------------------------------------------------------------------------------
--------- kind cluster---- install and run  
-> create an instance in aws and ssh it in system 
-> open kubestarter repositary in git hub and open kind cluster 
-> create a file install.sh and paste the command in it and give them full prmission and  run it in system 
-> install docker in your system 
-> kubectl version -> show version 
-> kind --version -> show version 
-> now create a kubernetes cluster 
-> check second step in git repo and create a config.yml file and paste the code for cluster in it 
->
                kind: Cluster
                apiVersion: kind.x-k8s.io/v1alpha4

                nodes:
                  - role: control-plane
                    image: kindest/node:v1.31.2
                  - role: worker
                    image: kindest/node:v1.31.2
                  - role: worker
                    image: kindest/node:v1.31.2

-> kind create cluster --config kind-cluster-config.yaml --name my-kind-cluster
-> kubectl get nodes -> information about all nodes 
-----------------------------------------------------------------------------------------------------------------
------- mini kube --------- install and run 
-> open git and shubham lodhe repo and open kubestarter 
-> open mini kube installer file and follow steps 
-> kubectl config user-context udit-cluster  ---> restore to the normal settings 
-----------------------------------------------------------------------------------------------------------------
------- kubeadm ----- install and run 
- create 2 instance  and ssh them in systwm 
- open kubeadm in git and follow commands
-----------------------------------------------------------------------------------------------------------------
- POD -
one pod can run one or more containers 
- namespace - the particular resources present in the namespace are belong to the particular group 
- docker container -> pod -> deployment -> service -> user access
- kubectl get ns -> show all name spaces 
- kubectl get pods -> show podes 
- kubectl create ns ngnix - create namespance ngenix 
- kubectl run nginix --image=nginix -> it will create a pod of nginix
- kubectl get pods - show list of pods 
- kubectl delete pod nginix - delete the pods 
- kubectl run nginix --image=nginix -n nginix - create th pod in particular name space 
- kubectl get pods -n nginix - list of the pods in the nginix name space 
-kubectl get pods -n nginix -o wide - give more info about pods 
- we can create all the pods ,deloyment , service through yml file which is called manifest file 
      -create a file namespace.yml
          -kind: Namespace
           apiVersion: v1 
           metadata: 
              name: nginix
      -save the file and use command "kubectl apply -f namespace.yml"
-now we create a pod 
    --create a file pod.yml 
        kind: pod 
        apiVersion: v1 
        metadata: 
          name: nginix-pod 
          namespace: nginix 
        spec: 
          containers: 
          - name: nginix
            image: nginix:latest
            ports: 
            - containerPost: 80
      - again use command "kubectl apply -f pod.yml"
-kubectl exec -it nginix-pod -n nginix -- bash     - with this we can enter inside the pods 

-Replica Set --> it create multiple copy of a pod
-Stateful Set -> it give address to a pod so that their state will maintain
-Deployment Set -> it  create replicasa and also give facility of rolling updates
              Rolling Updates - it allow to run the application during updates and prevent the app to stop . it give the update to podes one by one 
-Daemon Set ->  it ensure that each nodes have assigne atlest on pod running on it  

--DEPLOYMENT--  

- create a file deployment.yml and enter code in in 
      
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      name: nginix-dep-pod 
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
          
-kubecut apply -f deployment.yml - apply the file 
- kubectl scale deployment/nginix-deployment  -n nginix --replicas=5  - incase of heavy traffic we can increase the pod 
- kubectl set image deployment/nginix-deployment -n nginix niginx=nginx:1.27.3 = command is use to roll over new update of nginix in the pods 

--Replica Set-- we can only replicate the podes not use other features 

- create file Replicasets.yml
    kind: ReplicaSet
apiVersion: apps/v1
metadata:
  name: nginx-replicasets
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      name: nginix-rep-pod 
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80

- now apply 

-- Daemon Sets --

- create a file Daemonaset.yml

          kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: nginx-daemonsets
  labels:
    app: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      name: nginix-dem-pod 
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80

--now apply this 


-- jobs and crown jobs --

- job - the task done by single container
 - create job.yml
      
kind: Job
apiVersion: batch/v1
metadata:
  name: demo-job
  namespace: nginix
spec:
complition: 1
parallelism: 1
  template:
    metadata:
      name: demo-job-pod
      labels:
        app: batch-task
    spec:
      containers:
      - name: batch-container
        image : busybox: latest
        command: ["sh", "-c" ,"echo hello ! && sleep 10"]
        restartPolicy: never

- now apply 
- kubectl get job -n nginix  - check job status 
- kubectl logs pod/demo-job -n nginix - give out tht log 

-cron job - if the particular task run on any specific time . following a particular schedula and run the command 

-create cronJob.yml
      
kind: CronJob
apiVersion: batch/v1
metadata:
  name: minutUpdate e-backup
  namespace: nginix
spec:
  schedule: "* * * * *"
  jobTemplate:
    spec:
      template:
        metadata:
          name: hello
            labels:
              app: hello
          spec:
            containers:
            - name: hello
            image: busybox:1.28
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure

- cron guru - it is site use for scheduling the time 
- now apply

---------------------------------------------------------------------------------------STORAGE





















